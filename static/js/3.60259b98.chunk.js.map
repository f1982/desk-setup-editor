{"version":3,"sources":["../node_modules/three/examples/jsm/exporters/STLExporter.js"],"names":["__webpack_require__","r","__webpack_exports__","d","STLExporter","_home_runner_work_desk_setup_editor_desk_setup_editor_node_modules_babel_preset_react_app_node_modules_babel_runtime_helpers_esm_classCallCheck__WEBPACK_IMPORTED_MODULE_0__","_home_runner_work_desk_setup_editor_desk_setup_editor_node_modules_babel_preset_react_app_node_modules_babel_runtime_helpers_esm_createClass__WEBPACK_IMPORTED_MODULE_1__","three__WEBPACK_IMPORTED_MODULE_2__","Object","this","key","value","scene","output","options","arguments","length","undefined","binary","objects","triangles","traverse","object","isMesh","geometry","isBufferGeometry","Error","index","positionAttribute","getAttribute","count","push","object3d","offset","arrayBuffer","ArrayBuffer","DataView","setUint32","vA","vB","vC","cb","ab","normal","i","il","j","writeFace","getX","_j","a","b","c","fromBufferAttribute","isSkinnedMesh","boneTransform","applyMatrix4","matrixWorld","subVectors","cross","normalize","copy","setFloat32","x","y","z","writeNormal","writeVertex","setUint16","vertex"],"mappings":"yFAAAA,EAAAC,EAAAC,GAAAF,EAAAG,EAAAD,EAAA,gCAAAE,IAAA,IAAAC,EAAAL,EAAA,GAAAM,EAAAN,EAAA,GAAAO,EAAAP,EAAA,GAYAI,EAAA,WACA,SAAAA,IACII,OAAAH,EAAA,EAAAG,CAAeC,KAAAL,GAiJnB,OA9IEI,OAAAF,EAAA,EAAAE,CAAYJ,EAAA,EACdM,IAAA,QACAC,MAAA,SAAAC,GACA,IAsBAC,EAtBAC,EAAAC,UAAAC,OAAA,QAAAC,IAAAF,UAAA,GAAAA,UAAA,MACAG,OAAAD,IAAAH,EAAAI,QAAAJ,EAAAI,OAEAC,EAAA,GACAC,EAAA,EACAR,EAAAS,SAAA,SAAAC,GACA,GAAAA,EAAAC,OAAA,CACA,IAAAC,EAAAF,EAAAE,SAEA,QAAAA,EAAAC,iBACA,UAAAC,MAAA,oEAGA,IAAAC,EAAAH,EAAAG,MACAC,EAAAJ,EAAAK,aAAA,YACAT,GAAA,OAAAO,IAAAG,MAAA,EAAAF,EAAAE,MAAA,EACAX,EAAAY,KAAA,CACAC,SAAAV,EACAE,gBAKA,IAAAS,EAAA,GAEA,QAAAf,EAAA,CACA,IACAgB,EAAA,IAAAC,YADA,EAAAf,EAAA,EAAAA,EAAA,WAEAP,EAAA,IAAAuB,SAAAF,IACAG,UAAAJ,EAAAb,GAAA,GACAa,GAAA,OAEApB,EAAA,GACAA,GAAA,mBAUA,IAPA,IAAAyB,EAAA,IAAmB/B,EAAA,GACnBgC,EAAA,IAAmBhC,EAAA,GACnBiC,EAAA,IAAmBjC,EAAA,GACnBkC,EAAA,IAAmBlC,EAAA,GACnBmC,EAAA,IAAmBnC,EAAA,GACnBoC,EAAA,IAAuBpC,EAAA,GAEvBqC,EAAA,EAAAC,EAAA1B,EAAAH,OAA0C4B,EAAAC,EAAQD,IAAA,CAClD,IAAAtB,EAAAH,EAAAyB,GAAAZ,SACAR,EAAAL,EAAAyB,GAAApB,SACAG,EAAAH,EAAAG,MACAC,EAAAJ,EAAAK,aAAA,YAEA,UAAAF,EAEA,QAAAmB,EAAA,EAAyBA,EAAAnB,EAAAG,MAAiBgB,GAAA,GAI1CC,EAHApB,EAAAqB,KAAAF,EAAA,GACAnB,EAAAqB,KAAAF,EAAA,GACAnB,EAAAqB,KAAAF,EAAA,GACAlB,EAAAN,QAIA,QAAA2B,EAAA,EAA0BA,EAAArB,EAAAE,MAA8BmB,GAAA,GAOxDF,EANAE,EAAA,EAEAA,EAAA,EAEAA,EAAA,EAEArB,EAAAN,IASA,OAJA,IAAAJ,IACAL,GAAA,uBAGAA,EAEA,SAAAkC,EAAAG,EAAAC,EAAAC,EAAAxB,EAAAN,GACAgB,EAAAe,oBAAAzB,EAAAsB,GACAX,EAAAc,oBAAAzB,EAAAuB,GACAX,EAAAa,oBAAAzB,EAAAwB,IAEA,IAAA9B,EAAAgC,gBACAhC,EAAAiC,cAAAL,EAAAZ,GACAhB,EAAAiC,cAAAJ,EAAAZ,GACAjB,EAAAiC,cAAAH,EAAAZ,IAGAF,EAAAkB,aAAAlC,EAAAmC,aACAlB,EAAAiB,aAAAlC,EAAAmC,aACAjB,EAAAgB,aAAAlC,EAAAmC,aAeA,SAAAnB,EAAAC,EAAAC,GACAC,EAAAiB,WAAAlB,EAAAD,GACAG,EAAAgB,WAAApB,EAAAC,GACAE,EAAAkB,MAAAjB,GAAAkB,YACAjB,EAAAkB,KAAApB,GAAAmB,aAEA,IAAA1C,GACAL,EAAAiD,WAAA7B,EAAAU,EAAAoB,GAAA,GACA9B,GAAA,EACApB,EAAAiD,WAAA7B,EAAAU,EAAAqB,GAAA,GACA/B,GAAA,EACApB,EAAAiD,WAAA7B,EAAAU,EAAAsB,GAAA,GACAhC,GAAA,IAEApB,GAAA,kBAAA8B,EAAAoB,EAAA,IAAApB,EAAAqB,EAAA,IAAArB,EAAAsB,EAAA,KACApD,GAAA,oBA7BAqD,CAAA5B,EAAAC,EAAAC,GACA2B,EAAA7B,GACA6B,EAAA5B,GACA4B,EAAA3B,IAEA,IAAAtB,GACAL,EAAAuD,UAAAnC,EAAA,MACAA,GAAA,IAEApB,GAAA,gBACAA,GAAA,gBAuBA,SAAAsD,EAAAE,IACA,IAAAnD,GACAL,EAAAiD,WAAA7B,EAAAoC,EAAAN,GAAA,GACA9B,GAAA,EACApB,EAAAiD,WAAA7B,EAAAoC,EAAAL,GAAA,GACA/B,GAAA,EACApB,EAAAiD,WAAA7B,EAAAoC,EAAAJ,GAAA,GACAhC,GAAA,GAEApB,GAAA,gBAAAwD,EAAAN,EAAA,IAAAM,EAAAL,EAAA,IAAAK,EAAAJ,EAAA,UAMA7D,EAnJA","file":"static/js/3.60259b98.chunk.js","sourcesContent":["import _classCallCheck from \"/home/runner/work/desk-setup-editor/desk-setup-editor/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/classCallCheck\";\nimport _createClass from \"/home/runner/work/desk-setup-editor/desk-setup-editor/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/createClass\";\nimport { Vector3 } from 'three';\n/**\n * Usage:\n *  const exporter = new STLExporter();\n *\n *  // second argument is a list of options\n *  const data = exporter.parse( mesh, { binary: true } );\n *\n */\n\nvar STLExporter = /*#__PURE__*/function () {\n  function STLExporter() {\n    _classCallCheck(this, STLExporter);\n  }\n\n  _createClass(STLExporter, [{\n    key: \"parse\",\n    value: function parse(scene) {\n      var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n      var binary = options.binary !== undefined ? options.binary : false; //\n\n      var objects = [];\n      var triangles = 0;\n      scene.traverse(function (object) {\n        if (object.isMesh) {\n          var geometry = object.geometry;\n\n          if (geometry.isBufferGeometry !== true) {\n            throw new Error('THREE.STLExporter: Geometry is not of type THREE.BufferGeometry.');\n          }\n\n          var index = geometry.index;\n          var positionAttribute = geometry.getAttribute('position');\n          triangles += index !== null ? index.count / 3 : positionAttribute.count / 3;\n          objects.push({\n            object3d: object,\n            geometry: geometry\n          });\n        }\n      });\n      var output;\n      var offset = 80; // skip header\n\n      if (binary === true) {\n        var bufferLength = triangles * 2 + triangles * 3 * 4 * 4 + 80 + 4;\n        var arrayBuffer = new ArrayBuffer(bufferLength);\n        output = new DataView(arrayBuffer);\n        output.setUint32(offset, triangles, true);\n        offset += 4;\n      } else {\n        output = '';\n        output += 'solid exported\\n';\n      }\n\n      var vA = new Vector3();\n      var vB = new Vector3();\n      var vC = new Vector3();\n      var cb = new Vector3();\n      var ab = new Vector3();\n      var normal = new Vector3();\n\n      for (var i = 0, il = objects.length; i < il; i++) {\n        var object = objects[i].object3d;\n        var geometry = objects[i].geometry;\n        var index = geometry.index;\n        var positionAttribute = geometry.getAttribute('position');\n\n        if (index !== null) {\n          // indexed geometry\n          for (var j = 0; j < index.count; j += 3) {\n            var a = index.getX(j + 0);\n            var b = index.getX(j + 1);\n            var c = index.getX(j + 2);\n            writeFace(a, b, c, positionAttribute, object);\n          }\n        } else {\n          // non-indexed geometry\n          for (var _j = 0; _j < positionAttribute.count; _j += 3) {\n            var _a = _j + 0;\n\n            var _b = _j + 1;\n\n            var _c = _j + 2;\n\n            writeFace(_a, _b, _c, positionAttribute, object);\n          }\n        }\n      }\n\n      if (binary === false) {\n        output += 'endsolid exported\\n';\n      }\n\n      return output;\n\n      function writeFace(a, b, c, positionAttribute, object) {\n        vA.fromBufferAttribute(positionAttribute, a);\n        vB.fromBufferAttribute(positionAttribute, b);\n        vC.fromBufferAttribute(positionAttribute, c);\n\n        if (object.isSkinnedMesh === true) {\n          object.boneTransform(a, vA);\n          object.boneTransform(b, vB);\n          object.boneTransform(c, vC);\n        }\n\n        vA.applyMatrix4(object.matrixWorld);\n        vB.applyMatrix4(object.matrixWorld);\n        vC.applyMatrix4(object.matrixWorld);\n        writeNormal(vA, vB, vC);\n        writeVertex(vA);\n        writeVertex(vB);\n        writeVertex(vC);\n\n        if (binary === true) {\n          output.setUint16(offset, 0, true);\n          offset += 2;\n        } else {\n          output += '\\t\\tendloop\\n';\n          output += '\\tendfacet\\n';\n        }\n      }\n\n      function writeNormal(vA, vB, vC) {\n        cb.subVectors(vC, vB);\n        ab.subVectors(vA, vB);\n        cb.cross(ab).normalize();\n        normal.copy(cb).normalize();\n\n        if (binary === true) {\n          output.setFloat32(offset, normal.x, true);\n          offset += 4;\n          output.setFloat32(offset, normal.y, true);\n          offset += 4;\n          output.setFloat32(offset, normal.z, true);\n          offset += 4;\n        } else {\n          output += '\\tfacet normal ' + normal.x + ' ' + normal.y + ' ' + normal.z + '\\n';\n          output += '\\t\\touter loop\\n';\n        }\n      }\n\n      function writeVertex(vertex) {\n        if (binary === true) {\n          output.setFloat32(offset, vertex.x, true);\n          offset += 4;\n          output.setFloat32(offset, vertex.y, true);\n          offset += 4;\n          output.setFloat32(offset, vertex.z, true);\n          offset += 4;\n        } else {\n          output += '\\t\\t\\tvertex ' + vertex.x + ' ' + vertex.y + ' ' + vertex.z + '\\n';\n        }\n      }\n    }\n  }]);\n\n  return STLExporter;\n}();\n\nexport { STLExporter };"],"sourceRoot":""}